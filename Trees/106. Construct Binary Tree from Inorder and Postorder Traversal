106. Construct Binary Tree from Inorder and Postorder Traversal
class Solution {
public:
void createMapping(unordered_map<int,int> &valueToIndex,vector<int> inorder)
{
   for(int i=0;i<inorder.size();i++)
    {  int element=inorder[i];
    int index=i;
    valueToIndex[element]=index;
    }
}
  
 TreeNode* constructTree( unordered_map<int,int>& valMap,vector<int>& postorder,vector<int>& inorder,
 int& postIndex,int inorderStart, int inorderEnd, int size)
 {  //base case
    if(postIndex>=size)
    { //ruk jaana hai end se aage
        return NULL;
    }
    if(inorderStart>inorderEnd)
    {
        return NULL;
    }
     int element=postorder[postIndex];
     postIndex--; //aage karo index ko
     //node
     TreeNode* root= new TreeNode(element);
      int index=valMap[element];

      root->right=constructTree(valMap,postorder,inorder,postIndex,index+1,inorderEnd,size);

     root->left=constructTree(valMap,postorder,inorder,postIndex,inorderStart,index-1,size);
    
       return root;
 }
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        int postIndex=postorder.size()-1;
        int inorderStart=0;
        int inorderEnd=inorder.size()-1;
        int size=inorder.size();
        unordered_map<int,int> valMap;
        createMapping(valMap,inorder);
 TreeNode* root=constructTree(valMap,postorder,inorder,postIndex,inorderStart,inorderEnd,size);
        return root;
    }
};
